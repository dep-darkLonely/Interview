1. 悲观锁：总是假设最坏的情况，认为竞争总是存在，每次获取数据时都认为是被会
	修改的，因此每次都会先上锁，其他线程阻塞等待释放锁

2. 乐观锁：总是假设最好的情况，认为竞争总是不存在，每次获取数据时都认为是不
	会被修改的，因此不会上锁，数据更新时比较数据有无更新，可以通过版本号
	或者CAS实现

3. 自旋锁：是一种非阻塞锁，就是说，如果某线程需要获取锁，但该锁被其他线程占用
	该线程不会被挂起进入阻塞状态，而是不停的尝试试图获取锁。
	缺点：一直在试图获取锁，会一直消耗CPU，
	优点：避免了线程切换所带来的开销和损耗
	使用场景： 适合锁拥有时间比较短的情况
	自旋锁使线程处于用户态

4. 互斥锁：是一种阻塞锁，就是说，如果某线程需要获取锁，但该锁被其他线程占用，则
	线程则会被挂起，进入阻塞状态，不会消耗CPU
	互斥锁是线程处于内核态，需要切换CPU的执行权

5. 乐观锁实现方式：
	方式1：版本号机制：
		通过在数据库中增加version字段来实现
	方式2：CAS (Compare and Swap)
		需要使用三个操作数：旧值(内存中的值)、新值、要写入内存的值
		java.util.concurrent包中有一个AutomaticInteger这些类都是通过
		CAS来实现的，CAS属于原子操作，已经是不可分割的操作了
		CAS是通过硬件实现的，是一组汇编指令

6. 原子操作：就是指该操作是不可分割的操作了，要么全部成功，要去全部失败

7. CAS 全称为 Compare-And-Swap，就是对比交换，是基于硬件实现的一组汇编指令
	，其作用就是先比较两个值（内存中的值和旧值）然后，更新新值
	CAS操作是原子性的，所以多线程并发下，使用CAS更新数据库时，可以不使用锁
	CAS执行结果：执行结果要么成功要么失败，失败的情况下，会不断进行重试
	（自旋锁）

8. CAS中ABA问题：
	ABA问题：多线程的场景下发生ABA问题,发生场景如下：
		如有三个线程：
			1.线程1，期望值A, 欲更新的值为B
			2.线程2，期望值A, 欲更新的值为B
			3.线程3，期望值B, 与更新的值为A
			发生顺序为1和2(1正常，2阻塞)>3>2恢复，
			这种情况下存在ABA问题

	解决办法：
		1. 给变量增加版本号，每次变量更新的时候，版本号+1
		2. 使用AtomicStampedReference，实现方式和增加版本号类似，该
		    类是通过增加一个时间戳的形式

9. ConcurrentHashMap和HashTable 的线程安全实现方式不同：
	1. ConcurrentHashMap 底层采用的是 数据+链表+红黑树 实现，底层采用
		Synchronized和CAS实现；
		Synchronized主要用来锁当前链表或者红黑树的首节点，防止Hash冲突
	2. HashTable是基于HashMap实现的，底层采用的是数组+链表，
		采用的是Synchronized来实现的，增加的是一个全表锁

10. 可重入锁：自己可以再次获取自己的内部锁。比如：线程A获得了某个对象的锁，此时这个
	         对象还没有释放锁，当其再次想要获取这个对象的锁时，还可以继续获取；
	如果是不可重入锁的话，会造成死锁；线程获取一次锁，对象头的mark word中锁计数器
	会自增1，等计数器降为0时，才能释放锁

11. 公平锁：先等待的线程先获取锁，按照顺序获取锁
     非公平锁：所有线程都去争抢锁，不会按照顺序等待

12. Synchronized和ReentrantLock区别：
	1. 都是可重入锁
	2. Synchronized 依赖于JVM，ReenTrantLock依赖于API，需要使用lock和unlock来实现
	3. ReentrantLock的功能比Synchronized功能强大
		3.1 Synchronized 是非公平锁，ReentrantLock默认是非公平锁，可实现公平锁
		3.2 ReenTrantLock提供了一种可以中断等待锁的线程的机制，可以选择放弃等待锁
			改为处理其他事情
