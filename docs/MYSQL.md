# MYSQL

### 1. MySQL？

MySQL 关系型数据库，Java企业级开发中经常使用；免费、开源、稳定。

5.7版本之后，MySQL的默认存储引擎采用的是InnoDB，只有InnoDB是事务性存储引擎即只有InnoDB支持事务。

5.5版本之前，MySQL的默认存储引擎采用的是MyISAM。

### 2. MyISAM 与 InnoDB的区别？

存储引擎MyISAM与InnoDB之间的区别？

- MyISAM只支持表级别的锁；InnoDB支持表级别和行级别的锁，默认支持的是行级别的锁。

- MyISAM不支持事务；InnoDB支持事务。MyISAM强调的是性能，每次查询都具有原子性，其执行速度要比InnoDB类型更快，但是不提供事务。但是InnoDB支持事务，提供外键等高级数据库功能。具有commit、rollback和崩溃后修复能力。
- MyISAM不支持外键；InnoDB支持外键。
- MyISAM适用于读操作比较密集的数据库；InnoDB适用于写操作比较密集的数据库。

### 3. 索引

MySQL索引使用的数据结构主要有**BTree索引**和**哈希索引**。

[数据结构网站]: https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

**哈希索引**：底层的数据结构是哈希表，因此绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快。

**B+**: MySQL中BTree采用的是B+Tree。但是在InnoDB和MyISAM中B+tree的实现方式不同。

- MyISAM: 

    - B+Tree叶节点的data域存放的是**数据记录的地址**。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，索引文件在*.myi(MySQL5.7版本之前)，如果指定的key存在，则取出其data域的值，然后在以data域中的值为地址读取相应的数据记录。

        这就是"**非聚集索引**"（非聚簇索引）。所以MyISAM搜索引擎底层采用的是非聚集索引。

- InnoDB:

    - InnoDB与MyISAM存储引擎不同的是，其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按照B+Tree组织的一个索引结果，树的叶节点域中保存了完整的数据记录。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。这种方式被称为"**聚集索引**"(聚簇索引)。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录的主键的值而不是地址，这是和MyISAM是不相同的。
    - 在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先出去主键的值，做走一边主索引。因此在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

### 4. 数据结构介绍

MySQL中索引是一种数据结构，主要用于快速查找数据。

#### 4.1 二叉树

二叉树，顶端的节点我们成为**根节点**，没有子节点的节点我们称之为**叶节点**；

**特点**：

- 任何当前节点的左子节点的键值 < 当前节点的键值，右子节点的键值 > 当前节点的键值；

---

我们为下图的user表，创建一个二叉树查找索引。

![1](.\Image\MySQL\binarySearch.jpg)

如果我们需要查找id=12对应的信息，按照二叉树的特点，我们只需要3次就可以找到；

查找步骤：

1. 将根节点作为当前节点，因为12 > 10 ,所以应该查找根节点的右子节点信息。
2. 将12和13比较，因为12 < 13; 因此应该查找当前节点的左子节点。
3. 将12与12 进行比较，发现12=12，满足条件，我们从当前节点中取出其节点的信息。

查找结果验证：

![binarySearchResultValid](.\Image\MySQL\binarySearch.gif)

**结果**:

采用二叉树进行查找的话，我们只需要3次就能找到。但是，如果在表中进行一条一条的查找的话，需要6次。很明显查询效率提高了。

**问题**：

![image-20201003202527117](.\Image\MySQL\AvgBinarySearch.png)

如果二叉树变成上面的这种情况，即由二叉树 → 链表，当发生这种情况时，使用二叉树查找 和 在表中逐条查找，查询效率是相同的，全表扫描。

#### 4.2 平衡二叉树

平衡二叉树（AVL树），平衡二叉树可以很好解决二叉树退化为链表的问题。

**特点**：

- 它是空树或它的左右两个子树的高度差的绝对值不能超过1；并且左右两个子树都是一颗平衡二叉树。

**平衡二叉树 VS 非平衡二叉树**:

非平衡二叉树:

![image-20201003204727395](.\Image\MySQL\AvlBinarySearch.png)

平衡二叉树:

![image-20201003205013103](.\Image\MySQL\AvlBinarySearch_1.png)

非平衡二叉树经过旋转后得到平衡二叉树:

![image-20201003205013103](.\Image\MySQL\AvLbinarySearch.gif)

旋转方式有4中:左左、右右、左右、右左。

- 左左、右右只需要旋转一次就可平衡；
- 左右、右左需要旋转两次可以达到平衡；

**结论**:

- 与二叉树相比，平衡二叉树查询效率更稳定，查询速度更快。

**问题**:

**如果我们使用树(这种数据结构)作为索引的数据结构，那么我们每查找一次数据，就需要从磁盘中读取一个节点，也就是一个磁盘块。** 平衡二叉树可是每个节点只存储一个键值和数据。不满足大量数据，如果要用平衡二叉树实现大量数据的话，树的高度会非常的高，查找时会进行多次的磁盘IO操作，查询效率依然很低。

#### 4.3 B Tree（多路平衡搜索树）

B Tree 多路平衡搜索树，是一种常见的数据结构，主要是为磁盘等外存储设备设计的一种平衡查找树。

系统从磁盘读取数据到内存时是以"磁盘块(block)"为基本单位 的，位于同一个磁盘块中数据会被一次性读取出来，而不是需要什么，读取什么。

MySQL中InnoDB存储引擎中有页(Page)的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认的每个页的大小为16KB，可通过参数进行设置innodb_page_size将页的大小设置为4K、8K、16K

MySQL中的查询命令：

```mysql
show variables like 'innodb_page_size';
```

结果:

![image-20201003215532885](.\Image\MySQL\innodb_page_size.png)



系统中一个磁盘块的存储空间往往没有那么大，因此InnoDB每次申请磁盘空间时，都会申请若干地址连续的磁盘块来达到页的大小。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时，如果一个页中的每条数据都能有助于定位数据记录的位置，这将会大大的减少磁盘IO的次数，提高查询效率。

为了描述一个B-Tree，首先定义一条记录，该记录为一个二元组[key，data]，key为记录的键值，对应表中的主键值，data为一行记录中除了主键外的记录。对于不同的记录，key值互不相同。

B-Tree中每一个节点都可以包含大量的关键字信息，如图所示：

![索引](.\Image\MySQL\B-Tree.png)

- 一个节点上有2个关键字即键值，都是从小到大的顺序排列的；同时含有三个指向子树根节点的指针，指针中存储的是子节点所在磁盘快中的地址。

**模拟查找**：

查找key=29：

1. 根据根节点找到磁盘块1，读入到内存中。【I/O第一次】
2. 因为29 > 17,且 29 < 35,找到磁盘块1的指针P2.
3. 根据指针P2中存储的磁盘块3的地址，加载磁盘块3到内存中。【I/O第二次】
4. 比较键值，发现 29 > 26, 且 29 < 30，找到磁盘块3的指针P2。
5. 根据指针P2中存储的磁盘块8的地址，加载磁盘块8到内存中。【I/O第二次】
6. 比较键值，发现键值29.

分析上面的流程，只需要进行3次磁盘I/O操作，和3次内存查找操作进行。由于内存中的关键字是一个有序表结构，可以利用二分法快速查找，提高查询效率。3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。

B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了效率。

#### 4.4 B+ Tree

B+Tree 是在B-Tree基础上的一种优化，InnoDB存储引擎就是使用B+Tree实现的索引结构。

B-Tree中每个节点中不仅包含键值、指针而且还包含了data值，如果data值数据较大时，每页page中存储的键值数量就会少，同样会导致B-Tree的高度很高，影响查询效率。而在B+Tree中，所有数据节点都是按照键值从小到大的顺序存在在同一层的叶子节点上，而非叶子节点上只存储key信息，这样可以增加每个节点中存储key的数量，从而减低树的高度。

B-Tree优化之后，假设每次磁盘块有之前存储的2个键值信息，变为了4个键值信息，则变成B+Tree结构如图所示：

![索引](.\Image\MySQL\B+tree.png)

**特点**：

1. B+ Tree 树非叶子节点是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。

2. B+ 中索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。

3. B+ 中所有叶子节点之间是一种双向链表结构，因此B+Tree使的范围查找、排序查找、分组查找以及去重查找变得很简单。

    MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。

### 5. 聚集索引 VS 非聚集索引

不管是聚集索引还是非聚集索引，索引是一种数据结构。MySQL中InnoDB和MyISAM中都采用的B+Tree来实现。

#### 5.1 聚集索引

**定义**：

- 聚集索引的数据的物理存放顺序(在磁盘上存放的顺序)与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。

#### 5.2 非聚集索引

- 非聚集索引的数据的物理存放顺序(在磁盘上存放的顺序)与索引顺序是没有关系的。

### 6. MYSQL中存储方式

MySQL中有两种存储方式: InnoDB 和 MyISAM;

#### 6.1 InnoDB

- InnoDB采用的是B+Tree作为索引结构，索引页的默认大小为16KB，索引和表数据页共通存放在表空间中(文件后缀为*.ibd).从InnoDB表数据存放方式可以看出InnoDB表数据文件本身就是按照B+Tree组织的一个索引结构，Tree的叶子节点data域中保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。
- InnoDB默认是对主键建立聚集索引。如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚集索引。

#### 6.2 MyISAM

- MyISAM索引文件和数据文件是分离的，索引文件(*.MYI)和数据文件(**.myd),索引文件仅仅保存数据记录的地址。主索引和辅助索引采用的是非聚集索引。
- MyISAM引擎使用B+Tree作为索引结构，叶节点的data域中存放的是数据记录的地址。

### 7. MySQL最左匹配原则

**定义**：

在MySQL中，最左优先，以最左边的为起点任何连续的索引都能匹配上。同时如果遇到(>、<、between、like)就会停止匹配。

**ex**:

建立联合索引（a,b,c）:

1. 全值匹配查询时：

    ```mysql
    select * from table_name where a = '1' and b = '2' and c = '3' 
    select * from table_name where b = '2' and a = '1' and c = '3' 
    select * from table_name where c = '3' and b = '2' and a = '1'
    ```

    where  后面 的 a、b、c 列都在联合索引中存在，只是几个搜索条件顺序调换不影响查询结果，因为MySQL中存在查询优化器，查询优化器会进行自动优化顺序。

2. 匹配左边的列时：

    ```mysql
    select * from table_name where a = '1' 
    select * from table_name where a = '1' and b = '2'  
    select * from table_name where a = '1' and b = '2' and c = '3'
    ```

    都是从最左边开始连续匹配，使用到了索引；

    ```mysql
    select * from table_name where  b = '2' 
    select * from table_name where  c = '3'
    select * from table_name where  b = '1' and c = '3'
    ```

    **联合索引(a,b,c)**中最左边的为a列

    上面这些没有从最左边开始，最后查询没有用到索引，使用的是全表扫描

    ```mysql
    select * from table_name where a = '1' and c = '3' 
    ```

    如果查询时，where后面的查询条件在联合索引中是不连续的，如上面的SQL只适用到了a列的索引，b列和c列都没有用到。