# 锁

悲观锁：总是假设最坏的情况，认为竞争总是存在，每次获取数据时都认为是被会 修改的，因此每次都会先上锁，其他线程阻塞等待释放锁

乐观锁：总是假设最好的情况，认为竞争总是不存在，每次获取数据时都认为是不 会被修改的，因此不会上锁，数据更新时比较数据有无更新，可以通过版本号 或者CAS实现

自旋锁：是一种非阻塞锁，就是说，如果某线程需要获取锁，但该锁被其他线程占用 该线程不会被挂起进入阻塞状态，而是不停的尝试试图获取锁。 缺点：一直在试图获取锁，会一直消耗CPU， 优点：避免了线程切换所带来的开销和损耗 使用场景： 适合锁拥有时间比较短的情况 自旋锁使线程处于用户态

互斥锁：是一种阻塞锁，就是说，如果某线程需要获取锁，但该锁被其他线程占用，则 线程则会被挂起，进入阻塞状态，不会消耗CPU 互斥锁是线程处于内核态，需要切换CPU的执行权

乐观锁实现方式： 方式1：版本号机制： 通过在数据库中增加version字段来实现 方式2：CAS (Compare and Swap) 需要使用三个操作数：旧值(内存中的值)、新值、要写入内存的值 java.util.concurrent包中有一个AutomaticInteger这些类都是通过 CAS来实现的，CAS属于原子操作，已经是不可分割的操作了 CAS是通过硬件实现的，是一组汇编指令

原子操作：就是指该操作是不可分割的操作了，要么全部成功，要去全部失败

CAS 全称为 Compare-And-Swap，就是对比交换，是基于硬件实现的一组汇编指令 ，其作用就是先比较两个值（内存中的值和旧值）然后，更新新值 CAS操作是原子性的，所以多线程并发下，使用CAS更新数据库时，可以不使用锁 CAS执行结果：执行结果要么成功要么失败，失败的情况下，会不断进行重试 （自旋锁）

CAS中ABA问题： ABA问题：多线程的场景下发生ABA问题,发生场景如下： 如有三个线程： 1.线程1，期望值A, 欲更新的值为B 2.线程2，期望值A, 欲更新的值为B 3.线程3，期望值B, 与更新的值为A 发生顺序为1和2(1正常，2阻塞)>3>2恢复， 这种情况下存在ABA问题

解决办法： 1. 给变量增加版本号，每次变量更新的时候，版本号+1 2. 使用AtomicStampedReference，实现方式和增加版本号类似，该 类是通过增加一个时间戳的形式

ConcurrentHashMap和HashTable 的线程安全实现方式不同：

ConcurrentHashMap 底层采用的是 数据+链表+红黑树 实现，底层采用 Synchronized和CAS实现； Synchronized主要用来锁当前链表或者红黑树的首节点，防止Hash冲突
HashTable是基于HashMap实现的，底层采用的是数组+链表， 采用的是Synchronized来实现的，增加的是一个全表锁
可重入锁：自己可以再次获取自己的内部锁。比如：线程A获得了某个对象的锁，此时这个 对象还没有释放锁，当其再次想要获取这个对象的锁时，还可以继续获取； 如果是不可重入锁的话，会造成死锁；线程获取一次锁，对象头的mark word中锁计数器 会自增1，等计数器降为0时，才能释放锁

公平锁：先等待的线程先获取锁，按照顺序获取锁 非公平锁：所有线程都去争抢锁，不会按照顺序等待

Synchronized和ReentrantLock区别：

都是可重入锁
Synchronized 依赖于JVM，ReenTrantLock依赖于API，需要使用lock和unlock来实现
ReentrantLock的功能比Synchronized功能强大 3.1 Synchronized 是非公平锁，ReentrantLock默认是非公平锁，可实现公平锁 3.2 ReenTrantLock提供了一种可以中断等待锁的线程的机制，可以选择放弃等待锁 改为处理其他事情